{
    "collab_server" : "",
    "contents" : "#' Adaptive prior\n#'\n#' @param x\n#' @param degree\n#' @param nknot\n#' @param theta.prec\n#' @param type\n#'\n#' @return spde object\n#' @export\nbri.adapt.prior <- function(x, degree=3, nknot=5, theta.prec=0.01, type=c(\"indpt\", \"spde\", \"stat\")){\n\t# xx <- sort(unique(x))\n\trequire('splines')\n\tx.mesh = inla.mesh.1d(x)\n\tx.ind = inla.mesh.1d.bary(x.mesh,x,\"nearest\")$index[,1]\n\n\tn <- x.mesh$n\n\txx <- x.mesh$loc\n\tx.fem = inla.mesh.1d.fem(x.mesh)\n\tH = -x.fem$g1;\n\tH[1,] = 0; H[n,] = 0; ## Free boundaries.\n    G2 = t(H)%*%Diagonal(n, 1/diag(x.fem$c0))%*%H\n\n\tepsi <- 1e-8\n\tM0 <- Diagonal(n, epsi)\n\tM1 <- Diagonal(n, 0)\n\tM2 <- G2\n\n\n\tif(type=='indpt'){\n\t\t##B-spline basis\n\t\tprob <- seq(0, 1,, nknot)[2:(nknot-1)]\n\t\txk <- as.vector(quantile(x, prob=prob)) ## Knots\n\t\tbasis <- bs(xx, knots=xk, degree=degree, intercept=T)\n\n\t\t## mean and precision for theta\n\t\ttheta.mu <- rep(0, dim(basis)[2])\n\t\ttheta.Q <- diag(rep(theta.prec, dim(basis)[2]))\n\t} else if(type=='spde') {\n\t\t# SPDE precision\n\t\tprob.th <- seq(0, 1,, nknot)\n\t\txk.th <- as.vector(quantile(x, prob=prob.th))\n\t\txk.mesh = inla.mesh.1d(xk.th)\n\t\tbasis <- as.matrix(inla.mesh.1d.A(xk.mesh, xx, method='linear'))\n\n\t\t## mean and precision for theta\n\t\ttheta.mu <- rep(0, dim(basis)[2])\n\t\txk.fem = inla.mesh.1d.fem(xk.mesh)\n\t\tnk <- xk.mesh$n\n\t\tkappa <- 1\n\t\tHk = -xk.fem$g1;\n\t\tBk = Diagonal(nk, diag(xk.fem$c0))\n\t\tBk.inv = Diagonal(nk, 1/diag(xk.fem$c0))\n\t\ttheta.Q <- theta.prec*(kappa^2*Bk - kappa*(t(Hk) + Hk) +\n\t\t\t\tt(Hk)%*%Bk.inv%*%Hk)\n\t} else{\n\t\tbasis <- 1\n\t\ttheta.mu <- 0\n\t\ttheta.Q <- theta.prec\n\t}\n\n\tB0 <- cBind(0, basis)\n\tB1 <- cBind(0)\n\tB2 <- cBind(0)\n\n\n\tspde <- inla.spde2.generic(M0, M1, M2, B0, B1, B2,\n\t\t\ttheta.mu, theta.Q, transform=\"identity\", BLC = B0)\n\n\tspde$x.ind <- x.ind\n\treturn(spde)\n}\n\n#' Plot credible bands for a nonlinear function\n#'\n#' @param result\n#' @param name\n#' @param alpha\n#' @param ind\n#' @param type\n#' @param xlab\n#' @param ylab\n#' @param main\n#' @param hpd\n#' @param plot.data\n#'\n#' @return\n#' @export\n\nbri.band.ggplot <- function(result, name = NULL, alpha = 0.05, ind = NULL, type = c('random','fitted','linear'), xlab = NULL, ylab = NULL, main = NULL,  hpd = FALSE, plot.data = FALSE)\n{\n\tresult\n\tif(type == 'random'){\n\t\tpost.summary <- result$summary.random[[name]][ind,]\n\t\tmarg <- result$marginals.random[[name]][ind]\n\t}\n\tif(type == 'fitted'){\n\t\tpost.summary <- result$summary.fitted.values[ind,]\n\t\tmarg <- result$marginals.fitted.values[ind]\n\t}\n\tif(type == 'linear'){\n\t\tpost.summary <- result$summary.linear.predictor[ind,]\n\t\tmarg <- result$marginals.linear.predictor[ind]\n\t}\n\tif(hpd == TRUE){\n\t\t pp <- 1 - alpha\n\t\t tmp <- sapply(marg, function(x) inla.hpdmarginal(pp, x))\n\t\t fhat.lb <- tmp[1,]\n\t\t fhat.ub <- tmp[2,]\n\t} else{\n\t\tp.min <- alpha/2\n\t\tp.max <- 1 - alpha/2\n\t\tfhat.lb <- sapply(marg, function(x) inla.qmarginal(p.min, x))\n\t\tfhat.ub <- sapply(marg, function(x) inla.qmarginal(p.max, x))\n\t\tfhat.lb <- as.vector(fhat.lb)\n\t\tfhat.ub <- as.vector(fhat.ub)\n\t}\n\n\trequire(ggplot2,quietly = TRUE)\n\n\tfhat <- post.summary$mean\n\tif(is.null(name) == FALSE){\n\t\txx <- result$summary.random[[name]]$ID\n\t}else{\n\t\txx <- 1:length(fhat)\n\t}\n\tdata.plot <- data.frame(x = xx, fhat = fhat, f.lb = fhat.lb, f.ub = fhat.ub)\n\n\t# if(plot.data == TRUE){\n\t\t# p <- ggplot()\n\t# }\n\tggplot(data.plot, aes(x = x)) +\n\t\tgeom_line(aes(y = fhat)) +\n\t\tgeom_ribbon(aes(ymin = f.lb, ymax = f.ub), alpha = 0.2) +\n \t\ttheme_bw(base_size = 20) + labs(x = xlab, y = ylab) +\n \t\tggtitle(main)\n }\n\n#' Plot credible band for nonlinear functionTitle\n#'\n#' @param result\n#' @param name\n#' @param alpha\n#' @param ind\n#' @param xlab\n#' @param ylab\n#' @param main\n#' @param sub\n#' @param xlim\n#' @param ylim\n#' @param type\n#' @param hpd\n#'\n#' @return\n#' @export\nbri.band.plot <- function(result, name = NULL, alpha = 0.05, ind = NULL, xlab = NULL, ylab = NULL, main = NULL, sub = NULL, xlim = NULL, ylim = NULL, type = c('random','fitted','linear'), hpd = FALSE)\n{\n\tresult\n\tif(type == 'random'){\n\t\tpost.summary <- result$summary.random[[name]][ind,]\n\t\tmarg <- result$marginals.random[[name]][ind]\n\t}\n\tif(type == 'fitted'){\n\t\tpost.summary <- result$summary.fitted.values[ind,]\n\t\tmarg <- result$marginals.fitted.values[ind]\n\t}\n\tif(type == 'linear'){\n\t\tpost.summary <- result$summary.linear.predictor[ind,]\n\t\tmarg <- result$marginals.linear.predictor[ind]\n\t}\n\tif(hpd == TRUE){\n\t\t pp <- 1 - alpha\n\t\t tmp <- sapply(marg, function(x) inla.hpdmarginal(pp, x))\n\t\t fhat.lb <- tmp[1,]\n\t\t fhat.ub <- tmp[2,]\n\t} else{\n\t\tp.min <- alpha/2\n\t\tp.max <- 1 - alpha/2\n\t\tfhat.lb <- sapply(marg, function(x) inla.qmarginal(p.min, x))\n\t\tfhat.ub <- sapply(marg, function(x) inla.qmarginal(p.max, x))\n\t\tfhat.lb <- as.vector(fhat.lb)\n\t\tfhat.ub <- as.vector(fhat.ub)\n\t}\n\tfhat <- post.summary$mean\n\n\tif(is.null(name) == FALSE){\n\t\txx <- result$summary.random[[name]]$ID\n\t}else{\n\t\txx <- 1:length(fhat)\n\t}\n\tif(is.null(ylim) == TRUE) {\n\t\tylim <- c(min(fhat.lb), max(fhat.ub))\n\t}\n\tplot(xx, fhat, ylab = ylab, xlab = xlab, main = main, sub = sub,\n\t     cex.lab = 1.5, cex.axis = 1.5, xlim = xlim, ylim = ylim, type = 'n')\n\tlines(xx, fhat, lwd = 1.2)\n\tlines(xx, fhat.lb, lwd = 1.2, lty = 2)\n\tlines(xx, fhat.ub, lwd = 1.2, lty = 2)\n}\n#' TPS Prior\n#'\n#' @param mesh\n#' @param constr\n#' @param extraconstr.int\n#' @param extraconstr\n#' @param theta.mean\n#' @param theta.prec\n#'\n#' @return\n#' @export\nbri.tps.prior <- function(\n    mesh, constr = FALSE,\n\textraconstr.int = NULL,\n\textraconstr = NULL,\n\ttheta.mean = 0,\n\ttheta.prec = 1e-3){\n\tB.tau <- cbind(0, 1)\n    B.kappa <- cbind(log(1e-6), 0)\n    output <- inla.spde2.matern(mesh,\n    B.tau=B.tau, B.kappa=B.kappa,\n    theta.prior.mean = theta.mean,\n    theta.prior.prec = theta.prec)\n\toutput\n}\n\n#' Excursions\n#'\n#' @param result.inla\n#' @param name\n#' @param ind\n#' @param method\n#' @param u\n#' @param type\n#' @param alpha\n#'\n#' @return\n#' @export\nexcursions.brinla <- function(result.inla, name=NULL,\n\tind=NULL, method, u, type, alpha=0.05){\n\trequire(excursions)\n\tres.exc <- excursions.inla(result.inla, name=name,\n\t\tind=ind, method=method, u=u, type=type)\n\tF.out <- res.exc$F\n\tif(name == 'Predictor'){\n\t\tx <- 1:dim(result.inla$summary.linear.predictor)[1]\n\t}else{\n\t\tx <- result.inla$summary.random[[name]]$ID\n\t}\n\tE.out <- x[res.exc$F >= 1-alpha]\n\tG.out <- res.exc$F >= 1-alpha\n\trho.out <- res.exc$rho\n\tmean.out <- res.exc$mean\n\tvars.out <- res.exc$vars\n\toutput <- list(E = E.out, F = F.out, G = G.out,\n\t\trho = rho.out, mean = mean.out, vars = vars.out)\n\toutput\n}\n\n",
    "created" : 1474967788120.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1136191324",
    "id" : "8CB49D04",
    "lastKnownWriteTime" : 1474969097,
    "last_content_update" : 1474969097484,
    "path" : "~/publish/brinla/brinla/R/npr.R",
    "project_path" : "R/npr.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}